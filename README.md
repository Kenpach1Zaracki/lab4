# Лабораторная работа №4: Многопоточность

**Вариант 9 (Задание 2)** | **Вариант 3 (Задание 3)**

---

## Структура проекта

```
lab4/
├── task1/              # Задание 1: Примитивы синхронизации
│   ├── spinlock.h      # SpinLock и SpinWait
│   ├── monitor.h       # Monitor паттерн
│   ├── race_demo.cpp   # Демонстрация гонки символов
│   └── benchmark.cpp   # Бенчмарк примитивов
├── task2/              # Задание 2: Обработка данных о товарах
│   ├── product.h       # Структура товара
│   ├── generator.h/cpp # Генератор данных
│   ├── processor.h/cpp # Обработчик (одно/многопоточный)
│   └── main.cpp        # Главная функция
├── task3/              # Задание 3: Читатели-писатели
│   ├── readers_writers.h       # 3 варианта реализации
│   └── readers_writers_demo.cpp # Демонстрация
├── main_all.cpp        # Общее меню для всех заданий
└── Makefile            # Сборка проекта
```

---

## Компиляция и запуск

```bash
# Компиляция
make

# Запуск
./lab4_full

# Очистка
make clean

# Перекомпиляция
make rebuild
```

---

# ТЕОРИЯ

## 1. ОСНОВЫ МНОГОПОТОЧНОСТИ

### 1.1 Процессы и потоки

**Процесс** - это экземпляр выполняющейся программы, который имеет:
- Собственное адресное пространство памяти
- Код программы (секция .text)
- Данные (секции .data, .bss)
- Стек
- Кучу (heap)
- Дескрипторы ресурсов (файлы, сокеты и т.д.)

**Поток (Thread)** - это легковесная единица выполнения внутри процесса:
- Потоки одного процесса **разделяют** адресное пространство
- Каждый поток имеет **собственный стек**
- Потоки разделяют кучу, глобальные переменные, код
- Переключение между потоками быстрее, чем между процессами

**Отличия:**
```
Процессы:                  Потоки:
- Изолированная память     - Общая память
- Тяжелые (медленное       - Легкие (быстрое
  создание/переключение)     создание/переключение)
- Безопасность             - Риск гонки данных
- IPC для общения          - Прямой доступ к данным
```

### 1.2 Переключение контекста

**Контекст** - это состояние CPU для выполнения потока:
- Регистры процессора
- Указатель стека (SP)
- Счетчик команд (PC)
- Флаги состояния

**Переключение контекста** происходит когда:
1. Квант времени истек (time slice)
2. Поток блокируется (ждет I/O, блокировка)
3. Явное переключение (yield, sleep)

Операции:
1. Сохранить контекст текущего потока
2. Загрузить контекст следующего потока
3. Обновить таблицы памяти (если другой процесс)

**Накладные расходы:**
- Сохранение/восстановление регистров: ~1-10 мкс
- Очистка кэша CPU (cache invalidation)
- Обновление TLB (Translation Lookaside Buffer)

### 1.3 Многозадачность

#### Приоритетная (Preemptive) многозадачность
**ОС контролирует** переключение между задачами:

**Плюсы:**
- Гарантированная отзывчивость
- Справедливое распределение CPU
- Один процесс не может монополизировать CPU

**Минусы:**
- Накладные расходы на переключение
- Сложнее отладка (недетерминированное выполнение)

#### Кооперативная (Cooperative) многозадачность
**Задачи сами** отдают управление:

**Плюсы:**
- Меньше накладных расходов
- Детерминированное выполнение

**Минусы:**
- Один поток может заблокировать всю систему
- Требует дисциплины программирования

---

## 2. ПРИМИТИВЫ СИНХРОНИЗАЦИИ

### 2.1 Mutex (Mutual Exclusion)

**Назначение:** Взаимоисключение - только один поток в критической секции

```cpp
std::mutex mtx;

void criticalSection() {
    mtx.lock();         // Захват
    // Критическая секция
    mtx.unlock();       // Освобождение
}

// Безопаснее: автоматическое освобождение через RAII
void safeCriticalSection() {
    std::lock_guard<std::mutex> lock(mtx);
    // Критическая секция
} // Автоматический unlock при выходе из scope
```

**Принцип работы:**
1. Поток вызывает lock()
2. Если mutex свободен → захватывает, продолжает выполнение
3. Если занят → поток **засыпает** (переводится в состояние ожидания)
4. ОС пробуждает поток когда mutex освобождается

**Характеристики:**
- Экономит CPU (спящие потоки не потребляют ресурсы)
- Накладные расходы на переключение контекста (~1-10 мкс)
- Подходит для длительных критических секций

### 2.2 Semaphore (Семафор)

**Назначение:** Контроль доступа к ограниченному количеству ресурсов

```cpp
// Бинарный семафор (как mutex)
std::counting_semaphore<1> sem(1);

void access() {
    sem.acquire();  // Уменьшает счетчик, блокирует если 0
    // Работа с ресурсом
    sem.release();  // Увеличивает счетчик
}

// Ограничение пула ресурсов
std::counting_semaphore<5> pool(5);  // Максимум 5 потоков
```

**Сравнение с Mutex:**
```
Mutex:                    Semaphore:
- Владение (кто захватил, - Без владения (любой может
  тот освобождает)          release)
- Бинарный (0 или 1)      - Счетчик (0, 1, 2, ...)
- Взаимоисключение        - Ограничение ресурсов
```

### 2.3 Barrier (Барьер)

**Назначение:** Синхронизация группы потоков в точке встречи

```cpp
std::barrier<> barrier(5);  // 5 потоков

void phaseWork(int phase) {
    // Фаза 1: вычисления
    doWork(phase);

    // Все потоки ждут здесь
    barrier.arrive_and_wait();

    // Фаза 2: начинается только когда ВСЕ закончили фазу 1
    processResults();
}
```

**Применение:**
- Фазовые вычисления (итерационные алгоритмы)
- Параллельная обработка данных с зависимостями между шагами
- GPU-подобные вычисления

### 2.4 SpinLock (Активная блокировка)

**Назначение:** Ожидание без переключения контекста

```cpp
class SpinLock {
    std::atomic_flag flag = ATOMIC_FLAG_INIT;
public:
    void lock() {
        // Активное ожидание (spinning)
        while (flag.test_and_set(std::memory_order_acquire))
            ; // Крутимся в цикле
    }
    void unlock() {
        flag.clear(std::memory_order_release);
    }
};
```

**Плюсы:**
- Нет переключения контекста
- Быстрый для **коротких** критических секций (<100 нс)
- Низкая латентность

**Минусы:**
- Активно потребляет CPU
- Неэффективен при высокой конкуренции
- Может вызвать проблемы на системах с приоритетами

**Когда использовать:**
- Критическая секция < 100 наносекунд
- Низкая конкуренция потоков
- Real-time системы (детерминированная латентность)

### 2.5 SpinWait (Гибридный подход)

```cpp
class SpinWait {
    std::atomic_flag flag = ATOMIC_FLAG_INIT;
public:
    void lock() {
        while (flag.test_and_set(std::memory_order_acquire))
            std::this_thread::yield();  // Передаем управление
    }
    void unlock() {
        flag.clear(std::memory_order_release);
    }
};
```

**Компромисс:**
- Меньше нагрузки на CPU чем SpinLock
- Быстрее чем Mutex при короткой блокировке

### 2.6 Monitor (Монитор)

**Концепция:** Высокоуровневая абстракция синхронизации

Объединяет:
- Mutex (взаимоисключение)
- Condition Variable (ожидание условий)

```cpp
class Monitor {
    std::mutex mtx;
    std::condition_variable cv;
public:
    template<typename Func>
    void synchronized(Func func) {
        std::unique_lock<std::mutex> lock(mtx);
        func();
    }

    template<typename Predicate>
    void wait(Predicate condition) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, condition);
    }

    void notify_one() { cv.notify_one(); }
    void notify_all() { cv.notify_all(); }
};
```

**Применение:**
- Producer-Consumer паттерн
- Сложная координация потоков
- Ожидание событий

---

## 3. ИДИОМА RAII (Resource Acquisition Is Initialization)

**Принцип:** Ресурс захватывается в конструкторе, освобождается в деструкторе

**Проблема без RAII:**
```cpp
void riskyFunction() {
    mtx.lock();
    if (error) {
        return;  // ❌ Забыли unlock! Deadlock!
    }
    doWork();
    mtx.unlock();
}
```

**Решение с RAII:**
```cpp
void safeFunction() {
    std::lock_guard<std::mutex> lock(mtx);  // Конструктор: lock()
    if (error) {
        return;  // ✓ Деструктор автоматически вызовет unlock()
    }
    doWork();
} // Деструктор: unlock()
```

**Примеры RAII:**
- `std::lock_guard` - простая блокировка
- `std::unique_lock` - блокировка с отложенным захватом
- `std::shared_lock` - shared блокировка для чтения
- `std::scoped_lock` - множественная блокировка (C++17)

---

## 4. ПРОБЛЕМЫ МНОГОПОТОЧНОСТИ

### 4.1 Гонка данных (Race Condition)

**Определение:** Несколько потоков одновременно обращаются к одним данным, хотя бы один пишет

```cpp
int counter = 0;

void increment() {
    counter++;  // ❌ НЕ АТОМАРНО!
                //  1. Прочитать counter (LOAD)
                //  2. Увеличить (+1)
                //  3. Записать counter (STORE)
}

// Потоки A и B одновременно:
// A: LOAD (0) -> +1 (1) -> STORE (1)
// B: LOAD (0) -> +1 (1) -> STORE (1)
// Результат: counter = 1 (ожидали 2!)
```

**Решения:**
```cpp
// 1. Mutex
std::mutex mtx;
void safeIncrement() {
    std::lock_guard<std::mutex> lock(mtx);
    counter++;
}

// 2. Атомарные операции
std::atomic<int> counter{0};
void atomicIncrement() {
    counter.fetch_add(1);  // Атомарная операция
}
```

### 4.2 Deadlock (Взаимная блокировка)

**Определение:** Два или более потока ждут друг друга бесконечно

```cpp
std::mutex mtx1, mtx2;

void thread1() {
    mtx1.lock();
    std::this_thread::sleep_for(10ms);
    mtx2.lock();  // ❌ Ждет thread2
    // ...
    mtx2.unlock();
    mtx1.unlock();
}

void thread2() {
    mtx2.lock();
    std::this_thread::sleep_for(10ms);
    mtx1.lock();  // ❌ Ждет thread1
    // ...
    mtx1.unlock();
    mtx2.unlock();
}
```

**Условия возникновения Deadlock:**
1. Взаимоисключение (Mutual Exclusion)
2. Удержание и ожидание (Hold and Wait)
3. Отсутствие вытеснения (No Preemption)
4. Циклическое ожидание (Circular Wait)

**Решения:**
```cpp
// 1. Упорядоченный захват (всегда в одном порядке)
void safeThread() {
    std::scoped_lock lock(mtx1, mtx2);  // Захватывает в безопасном порядке
    // ...
}

// 2. Попытка захвата с таймаутом
void timeoutThread() {
    std::unique_lock<std::mutex> lock1(mtx1, std::defer_lock);
    if (lock1.try_lock_for(100ms)) {
        // Успешно
    } else {
        // Таймаут - избежали deadlock
    }
}

// 3. Захват всех блокировок одновременно
std::lock(mtx1, mtx2);  // Атомарно захватывает обе
```

### 4.3 Голодание (Starvation)

**Определение:** Поток не может получить доступ к ресурсу из-за приоритетов

**Пример:** В реализации с приоритетом писателей, читатели могут голодать

---

## 5. ЗАКОН АМДАЛА (Amdahl's Law)

**Формулировка:** Максимальное ускорение программы при использовании N процессоров:

```
S(N) = 1 / ((1 - P) + P/N)

где:
- P = доля кода, которая может выполняться параллельно
- (1-P) = последовательная часть
- N = количество процессоров
```

**Примеры:**

1. **P = 0.5** (50% параллелизуется):
   ```
   N=2:  S = 1 / (0.5 + 0.5/2) = 1.33x
   N=4:  S = 1 / (0.5 + 0.5/4) = 1.6x
   N=∞:  S = 1 / 0.5 = 2x  (максимум!)
   ```

2. **P = 0.9** (90% параллелизуется):
   ```
   N=2:  S = 1 / (0.1 + 0.9/2) = 1.82x
   N=4:  S = 1 / (0.1 + 0.9/4) = 3.08x
   N=∞:  S = 1 / 0.1 = 10x
   ```

**Вывод:**
- Даже с бесконечным количеством процессоров, ускорение ограничено последовательной частью
- 10% последовательного кода → максимум 10x ускорение
- Важно минимизировать последовательные участки

---

## 6. МОДЕЛИ ПАМЯТИ И АТОМАРНОСТЬ

### 6.1 Memory Order (Порядок памяти)

```cpp
std::atomic<int> x{0};

// memory_order_relaxed - без гарантий порядка
x.store(1, std::memory_order_relaxed);

// memory_order_acquire - гарантирует видимость предыдущих операций
x.load(std::memory_order_acquire);

// memory_order_release - гарантирует видимость текущих операций
x.store(1, std::memory_order_release);

// memory_order_seq_cst - полная последовательная согласованность (по умолчанию)
x.store(1);  // Эквивалентно memory_order_seq_cst
```

### 6.2 Атомарные операции

```cpp
std::atomic<int> counter{0};

counter.fetch_add(1);    // Атомарно: counter += 1
counter.fetch_sub(1);    // Атомарно: counter -= 1
counter.exchange(10);    // Атомарно: old = counter; counter = 10; return old;

// Compare-And-Swap
int expected = 5;
int desired = 10;
counter.compare_exchange_strong(expected, desired);
// Если counter == expected, то counter = desired, возвращает true
// Иначе expected = counter, возвращает false
```

---

## 7. ЗАДАЧА ЧИТАТЕЛИ-ПИСАТЕЛИ

### 7.1 Постановка задачи

**Правила:**
- Несколько читателей могут читать одновременно
- Писатель требует эксклюзивного доступа
- Писатели и читатели не могут работать одновременно

### 7.2 Приоритет читателей

```cpp
std::shared_mutex mtx;

void reader() {
    mtx.lock_shared();   // Несколько читателей OK
    // Чтение
    mtx.unlock_shared();
}

void writer() {
    mtx.lock();          // Эксклюзивный доступ
    // Запись
    mtx.unlock();
}
```

**Характеристики:**
- Максимальная пропускная способность чтения
- Писатели могут голодать

### 7.3 Приоритет писателей

```cpp
int readers = 0;
int waiting_writers = 0;
bool active_writer = false;
std::mutex mtx;
std::condition_variable cv_read, cv_write;

void start_write() {
    std::unique_lock lock(mtx);
    waiting_writers++;
    cv_write.wait(lock, []{ return readers == 0 && !active_writer; });
    waiting_writers--;
    active_writer = true;
}

void end_write() {
    std::unique_lock lock(mtx);
    active_writer = false;
    if (waiting_writers > 0)
        cv_write.notify_one();   // Приоритет писателям
    else
        cv_read.notify_all();
}
```

**Характеристики:**
- Актуальные данные
- Читатели могут голодать

---

## 8. АСИНХРОННОСТЬ VS МНОГОПОТОЧНОСТЬ

### Многопоточность
- Истинный параллелизм
- Несколько потоков выполняются одновременно на разных ядрах
- Подходит для CPU-bound задач

### Асинхронность
- Конкурентность без параллелизма
- Один поток обрабатывает множество задач
- Подходит для I/O-bound задач

**Event Loop:**
```
while (true) {
    event = wait_for_event();
    handle_event(event);
}
```

**Пример:**
- Многопоточность: математические вычисления
- Асинхронность: веб-сервер (ожидание сети)

---

## 9. ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ

### 9.1 Выбор примитива синхронизации

| Задача | Рекомендация |
|--------|-------------|
| Критическая секция <100нс | SpinLock |
| Критическая секция >100нс | std::mutex |
| Ограничение ресурсов | std::counting_semaphore |
| Фазовые вычисления | std::barrier |
| Producer-Consumer | Monitor / std::condition_variable |
| Чтение >> Запись | std::shared_mutex |

### 9.2 Избежание проблем

**Deadlock:**
- Всегда захватывайте блокировки в одном порядке
- Используйте `std::scoped_lock` для множественных блокировок
- Не вызывайте внешний код под блокировкой

**Race Condition:**
- Используйте `std::atomic` для простых переменных
- Защищайте сложные структуры данных mutex'ом
- Минимизируйте общее состояние

**Производительность:**
- Минимизируйте время в критической секции
- Используйте lock-free структуры данных когда возможно
- Измеряйте производительность (бенчмаркинг)

---

## 10. ГОРУТИНЫ (Go) И GIL (Python)

### Горутины (Goroutines)
- Легковесные потоки (stacksize ~2KB)
- M:N scheduling (M горутин на N OS threads)
- Встроенные примитивы: channels, select

### GIL (Global Interpreter Lock)
- Python: только один поток выполняет байткод одновременно
- Защищает внутренние структуры интерпретатора
- Многопоточность не дает ускорения для CPU-bound задач
- Решение: multiprocessing (отдельные процессы)

---

## ЗАКЛЮЧЕНИЕ

Многопоточность - мощный инструмент, но требует:
- Понимания примитивов синхронизации
- Знания потенциальных проблем
- Тщательного тестирования
- Измерения производительности

**Золотое правило:** Сначала проверьте, нужна ли вообще многопоточность!
# lab4
